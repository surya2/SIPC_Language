# Deliverable 4 Solution Design

## General Procedure
Most feature implementation was generally straightforward. Unary, Binary statements just took additions to the if-else blocks of the existing code, and the for loop with start and end used roughly similar constructions as the while look. The majority of the work was in the array, and array-related code gen functions. We followed the normal conventions from other parts of the code base as a convention to make the new features. 

## Arrays
Arrays and downstream functions took the bulk of the work in this assignment. We implemented many many many versions of arrays before things started working. The biggest issue across  The final version uses a struct with the length of the array and a pointer to the array. It also uses calloc to store this on the heap. Returning a struct is helpful because it allows other functions to extract the length from the array. This is how ASTArrayRefExpr::codegen (array reference/access) and ASTIterLoopStmt::codegen (Iterator loop) can do bounds checking. This struct is made up of a pointer to the size of the array which is the first element of the struct and the pointer to the first element pointer which is the second element of the struct. Thus, the iterator loop and array reference codegen() functions would extract each element of the struct, passed in the llvmContext, and dereference each pointer to get the size of the given array and the pointer to the first element of the array.

There was some difficulty in referencing this struct in ArrayRef and Iter, because the return value struct ptr is casted into an llvm::Value int64. Thus we had to add the int to pointer cast to retrieve the original pointer. Once this was implemented, using the struct to retrieve the array worked fine. The other difficulty was getting array assignment to work because it was often causing a segmentation fault. However, we ultimately realized we needed to factor in whether the array reference was an l-value taken from the assignment statement to determine if we are supposed to return the value at that position, or a pointer to that value. We additionally need to set the *lValueGen* to *false* after entering the array reference codegen() function, and instead set an internal variable to the value of *lValueGen* so that a more complex array reference such as arr[i][j] would not be entirely considered as an l-value. Once we got the correct pointer returning, we no longer had issues with segmentation faults from the wrong pointers.

Once this structure of storing the arrays was functional, most of the remainder of array functions were generally trivial. We had to implement iter statements, which followed the structure of for loops using the same code to index the array that we used in array ref, and array length operator followed the same structure used in array reference's codegen() function to get the length in the array struct for bounds checking. Lastly, we had to implement the ofArrays, with the main constraint that they had to follow the same array struct at Array.

## Testing 

We tested with compiled self-testing. This introduced a lot of complexity, so to isolate just our new tests, we both added test runners to run.sh, but also created `runsipc.sh`, which is ran with `./runtests.sh -n`. This script compiles and runs all of the tests, and keeps a record of what passed and failed. Additionally, we added a section to `run.sh` that procedurally generated and saved the pretty printer files as a means of comparison. This made testing much faster because we could iteratively test just the new tests that we wanted to target.

The tests separate out each feature we implemented separately. They also implement relevant edge cases to make sure the code still works. By testing many different cases we were able to check many edge cases that we otherwise would have missed, which helped us ensure our code was functional. One debugging trick that was particularly helpful was using error and output to get information in the terminal. Using TIP's already built in `error` statement allowed us to test new SIP features through the language itself. In other words, after executing some snippet of code and returning the result from the code, we could use an if statement to check whether the expected result was returned and if not, generate an error output. In the case of an error output, there is a procedural error in the code that could be due to issues in our CodeGenFunctions.cpp.

The hardest tests to debug were those returning segmentation faults, as often happened with array-related tests. With these, we used output to find the lastest portions of the test working and identify where the segfault (or other system errors) happened. From there we could backtrack and find the root of the segfault, although this often proved very difficult. 



